{
  "id": "fastapi-practices",
  "title": "FastAPI Best Practices",
  "excerpt": "Dependency injection, Pydantic, async I/O, and deployment patterns for production-ready FastAPI apps.",
  "category": "Tutorial",
  "date": "2024-11-15",
  "author": "Keerthan Venkata",
  "featured": false,
  "content_html": "<p>FastAPI makes it easy to ship an API quickly, but production readiness comes from a few deliberate choices. Here’s what I use on real projects: dependency injection, Pydantic everywhere, background tasks, and clear error handling.</p>\n<h2>Dependency Injection</h2>\n<p>Use FastAPI’s <code>Depends()</code> for everything that can be configured or swapped: DB sessions, config, clients (e.g. LLM or storage). Define a function that returns the dependency and inject it into route handlers. That gives you a single place to control lifecycle (e.g. one session per request) and makes testing trivial—you override the dependency in the test client instead of patching globals.</p>\n<pre><code class=\"language-python\">def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@router.post(&quot;/items&quot;)\ndef create_item(item: ItemCreate, db: Session = Depends(get_db)):\n    ...\n</code></pre>\n<p>Keep dependencies thin: they should create or fetch an object, not contain business logic.</p>\n<h2>Pydantic for Request and Response</h2>\n<p>Define Pydantic models for every request body and response. Use <code>response_model</code> (or <code>response_model_exclude_none</code>) so the API contract is explicit and docs stay accurate. For validation, use custom validators and <code>Field()</code> for constraints and descriptions. That way invalid input is rejected at the edge and your handlers work with typed objects, not raw dicts. For large or nested responses, consider <code>model_config = ConfigDict(from_attributes=True)</code> and returning ORM models only where you need to avoid N+1; otherwise prefer explicit response models.</p>\n<h2>Background Tasks and Async</h2>\n<p>For work that doesn’t need to block the response (emails, post-processing, enqueueing jobs), use <code>BackgroundTasks</code>. Add the task in the route and return immediately; FastAPI runs it after the response is sent. For I/O-bound work (DB, HTTP calls to LLMs or external APIs), use <code>async</code> route handlers and async libraries (e.g. <code>asyncpg</code>, <code>httpx</code>) so a single process can handle many concurrent requests without blocking. Don’t mix blocking calls in async routes—offload those to a thread pool or a worker.</p>\n<h2>Exception Handlers</h2>\n<p>Register custom exception handlers with <code>@app.exception_handler()</code>. Map domain exceptions (e.g. <code>ValidationError</code>, <code>NotFound</code>) to HTTP status codes and a consistent JSON shape (e.g. <code>{&quot;detail&quot;: &quot;...&quot;, &quot;code&quot;: &quot;...&quot;}</code>). That way clients get predictable errors and you can log and monitor by exception type. For validation errors from Pydantic, FastAPI’s default 422 is fine; for business rules, use 4xx and reserve 5xx for unexpected failures.</p>\n<h2>Testing and Deployment</h2>\n<ul>\n<li><strong>Tests</strong>: Use <code>TestClient</code> and override dependencies (e.g. in-memory DB or mock LLM client) so routes are tested in isolation. Test success and failure paths and that response models match what you expect.</li>\n<li><strong>Deployment</strong>: Run behind a reverse proxy (e.g. Nginx or a cloud load balancer). Use workers (e.g. Gunicorn with uvicorn workers) and set worker count from CPU and I/O characteristics. Pull config from environment variables or a secret manager; never hardcode secrets. Health checks (<code>/health</code> or <code>/ready</code>) should verify DB and critical dependencies so the orchestrator can restart unhealthy instances.</li>\n</ul>\n<p>Adopting these patterns keeps FastAPI apps maintainable, testable, and ready for production traffic.</p>\n"
}